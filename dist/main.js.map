{"version":3,"file":"main.js","sources":["../src/abiParser.js","../src/stateFormatters.js","../src/formatState.js","../src/main.js"],"sourcesContent":["import _ from 'lodash'\n\nexport const constantFunctionNames = (abi) => {\n  return _.map(_.filter(abi, { type: 'function', constant: true }), o => o.name)\n}\n\nexport const transactionFunctionNames = (abi) => {\n  return _.map(_.filter(abi, { type: 'function', constant: false }), o => o.name)\n}\n\nexport const getOutputType = (abi, fnName) => {\n  return _.find(abi, { name: fnName }).outputs[0].type\n}\n","export default {\n  uint256: v => v.toNumber(),\n  uint: v => v.toNumber(),\n  address: v => v,\n  bool: v => v\n}\n","import _ from 'lodash'\nimport { getOutputType } from './abiParser'\nimport formatters from './stateFormatters'\n\nexport default (abi, rawState) => {\n  let formattedState = {}\n  _.forEach(rawState, (val, prop) => {\n    const outputType = getOutputType(abi, prop)\n    const formatter = formatters[outputType]\n    if (!formatter) {\n      throw new Error(`No formatter found for ${outputType}`)\n    }\n    formattedState[prop] = formatter(val)\n  })\n  return formattedState\n}\n","import _ from 'lodash'\nimport {\n  constantFunctionNames,\n  transactionFunctionNames\n} from './abiParser'\nimport formatState from './formatState'\n\nasync function contractState (contractInstance) {\n  const fnNames = constantFunctionNames(contractInstance.abi)\n  const results = await Promise.all(_.map(fnNames, (fnName) => {\n    return contractInstance[fnName].call()\n  }))\n  let state = {}\n  for (let i = 0; i < fnNames.length; i++) {\n    state[fnNames[i]] = results[i]\n  }\n  return state\n}\n\nfunction wrapTxFunction (contractInstance, fnName) {\n  const txFn = contractInstance[fnName]\n  return async function () {\n    let tx = await txFn.apply(this, Array.prototype.slice.call(arguments))\n    const state = await contractState(contractInstance)\n    return _.assign(tx, { state })\n  }\n}\n\nfunction transactionFns (contractInstance) {\n  const txFnNames = transactionFunctionNames(contractInstance.abi)\n  let txFns = {}\n  _.forEach(txFnNames, (fnName) => {\n    txFns[fnName] = wrapTxFunction(contractInstance, fnName)\n  })\n  return txFns\n}\n\nfunction wrapContractInstance (contractInstance, state) {\n  return _.assign(\n    contractInstance,\n    transactionFns(contractInstance),\n    {\n      state: state,\n      formattedState: formatState(contractInstance.abi, state)\n    }\n  )\n}\n\nfunction newContractFn (newFn) {\n  return async function () {\n    const c = await newFn.apply(this, Array.prototype.slice.call(arguments))\n    const state = await contractState(c)\n    return wrapContractInstance(c, state)\n  }\n}\n\nfunction wrapContractArtifact (contractArtifact) {\n  contractArtifact.new = newContractFn(contractArtifact.new)\n  return contractArtifact\n}\n\nexport function requireContract (contractArtifact) {\n  return wrapContractArtifact(contractArtifact)\n}\n\n/*\nexport const types = {\n  Address: 'address',\n  Balance: 'balance',\n  Number: 'number',\n  Tx: 'tx'\n}\n\nconst formatters = {\n  [types.Address]: (v) => { return v },\n  [types.Balance]: (v) => { return toEth(v.toNumber()) },\n  [types.Number]: (v) => { return v.toNumber() }\n}\n\nfunction formatState (def, rawState) {\n  let formatted = _.assign({}, rawState)\n  _.forEach(rawState, (val, prop) => {\n    formatted[prop] = formatters[def[prop]](val)\n  })\n  return formatted\n}\n\nfunction nonTxFnNames (def) {\n  return fnNamesWithoutType(def, types.Tx)\n}\n\nfunction fnNamesWithoutType (def, t) {\n  const fnNames = []\n  _.forEach(def, (val, key) => {\n    if (val !== t) {\n      fnNames.push(key)\n    }\n  })\n  return fnNames\n}\n\nfunction fnNamesByType (def, t) {\n  const fnNames = []\n  _.forEach(def, (val, key) => {\n    if (val === t) {\n      fnNames.push(key)\n    }\n  })\n  return fnNames\n}\n\nfunction getExecFn (contractInstance, def, txFnName) {\n  return async function () {\n    const argsArray = Array.prototype.slice.call(arguments)\n    console.log('CALLING TX FN: ', txFnName)\n    console.log('args: ', argsArray)\n    const txRes = await contractInstance[txFnName].apply(null, argsArray)\n    const rawState = await contractState(contractInstance, def)\n    return {\n      tx: txRes,\n      state: formatState(def, rawState),\n      rawState\n    }\n  }\n}\n\nasync function contractState (contractInstance, def) {\n  const callFnNames = nonTxFnNames(def)\n  const results = await Promise.all(_.map(callFnNames, (fnName) => {\n    return contractInstance[fnName].call()\n  }))\n  let state = {}\n  for (let i = 0; i < callFnNames.length; i++) {\n    state[callFnNames[i]] = results[i]\n  }\n  return state\n}\n\nfunction transactionFns (contractInstance, def) {\n  let exec = {}\n  _.forEach(fnNamesByType(def, types.Tx), (txFnName) => {\n    exec[txFnName] = getExecFn(contractInstance, def, txFnName)\n  })\n  return exec\n}\n\nexport async function trest (contractInstance, def) {\n  const rawState = await contractState(contractInstance, def)\n  return {\n    exec: transactionFns(contractInstance, def),\n    state: formatState(def, rawState),\n    rawState\n  }\n}\n\n*/\n\n/*\nmodule.exports.call = async (callPromise) => {\n  let returnVal = await callPromise\n\n  const assertReturnValue = (expectedReturnVal) => {\n    assert.equal(\n      returnVal,\n      expectedReturnVal,\n      `expected ${expectedReturnVal} to be returned, but got ${returnVal}`\n    )\n  }\n\n  return {\n    returnValue: returnVal,\n    assertReturnValue\n  }\n}\n\nmodule.exports.tx = async (transactionPromise) => {\n  let err, resp\n  try {\n    resp = await transactionPromise\n  } catch (_err) {\n    err = _err\n  }\n\n  const events = {}\n\n  events.filter = (event) => {\n    return _.filter(resp.logs, { event })\n  }\n\n  events.log = () => {\n    _.forEach(resp.logs, (log) => {\n      console.log(`${log.event}: `, log.args)\n    })\n  }\n\n  const assertLogEvent = (eventParams) => {\n    const filteredEvents = events.filter(eventParams.event)\n    assert.equal(filteredEvents.length, 1, `expected 1 ${eventParams.event} event but got ${filteredEvents.length}`)\n    const event = filteredEvents[0]\n    _.forEach(_.keys(eventParams), (p) => {\n      if (p !== 'event') {\n        assert.equal(\n          event.args[p],\n          eventParams[p],\n          `expected event property '${eventParams.event}.${p}' to be ${eventParams[p]}, ` +\n            `but got ${event.args[p]}`\n        )\n      }\n    })\n  }\n\n  const assertThrewError = () => {\n    assert.equal(\n      typeof err === 'undefined',\n      false,\n      `expected an error, but no error was thrown`\n    )\n  }\n\n  return {\n    response: resp,\n    error: err,\n    events,\n    assertLogEvent,\n    assertThrewError\n  }\n}\n*/\n"],"names":["constantFunctionNames","abi","_","map","filter","type","constant","o","name","transactionFunctionNames","getOutputType","fnName","find","outputs","v","toNumber","rawState","formattedState","forEach","val","prop","outputType","formatter","formatters","Error","contractInstance","fnNames","results","Promise","all","call","state","i","length","contractState","wrapTxFunction","txFn","tx","apply","Array","prototype","slice","arguments","assign","transactionFns","txFnNames","txFns","wrapContractInstance","formatState","newContractFn","newFn","c","wrapContractArtifact","contractArtifact","new","requireContract"],"mappings":"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"}